%{
#include <bits/stdc++.h>
#include "symbol.hpp"
//#define YYSTYPE char*
using namespace std;
struct Point {
	double x, y;
	Point(double x=0.d, double y=0.d):x(x), y(y) {}
	Point operator +(Point other) {return Point(x+other.x, y+other.y);}
	Point operator -(Point other) {return Point(x-other.x, y-other.y);}
	Point operator *(double c) {return Point(x*c, y*c);}
	Point operator /(double c) {return Point(x/c, y/c);}
	bool operator <(Point other) {return x<other.x or x==other.x and y<other.y;}
	bool operator >(Point other) {return other < *this;}
	bool operator ==(Point other) {return x==other.x and y==other.y;}
	bool operator !=(Point other) {return not(*this==other);}
	bool operator <=(Point other) {return *this<other or *this==other;}
	bool operator >=(Point other) {return other<=*this;}
};
void yyerror(const char*);
char lexema[maxN];
int yylex();
int tempVarN = 0;
int genTempVar();

%}

%start program
%token POINT
%token NUM VAR
%token ADD SUB 
%token MUL DIV
%token POW
%token AND OR
%token OP CP
%token OB CB
%token EQUAL ASSING DIFF
%token INIT END
%token IF ELSE
%token WHILE FOR COMPARATOR
%token DOTCOM COMMA
%token DATATYPE

%%

program: INIT block END;

block: 
	| if_sentence block
	| while_loop block
	| for_loop block
	| funcion block
	| assignation block
	| declaration block
;

funcion: VAR OP args CP OB block CB;
args: /* no arguments */
	| arg
	| args COMMA arg
;
arg: term
;

if_sentence: IF OP logicList CP OB block CB;

while_loop: WHILE OP logicList CP OB block CB;

for_loop: FOR OP declaration DOTCOM logicList DOTCOM assignation CP OB block CB;

logicList: condition
	| logicList AND condition
	| logicList OR condition
;

condition: term COMPARATOR term ;

assignation: term EQUAL exp { genCode(ASSING, $1, $3, '-'); } DOTCOM;

declaration: DATATYPE VAR {$2 = putSymb(lexema, VAR, 0);} EQUAL exp { genCode(ASSING, $2, $5, '-'); } DOTCOM;

exp: factor
	| exp ADD factor {int i = genTempVar(); genCode(ADD, i, $1, $3); $$ = i; }
	| exp SUB factor {int i = genTempVar(); genCode(SUB, i, $1, $3); $$ = i; }
;

factor: factor2
	| factor MUL factor2 {int i = genTempVar(); genCode(MUL, i, $1, $3); $$ = i; }
	| factor DIV factor2 {int i = genTempVar(); genCode(DIV, i, $1, $3); $$ = i; }
;

factor2: term
	| factor2 POW NUM { int i = genTempVar(); genCode(POW, i, $1, $3); $$ = i; }
	| OP  exp CP
;

term: VAR { $$ = putSymb(lexema, VAR, 0); }
	| NUM { $$ = putSymb(lexema, NUM, 1); }
	| POINT { $$ = putSymb(lexema, POINT, 0);}
;

%%

int genTempVar() {
    char t[64];
    sprintf(t, "T_%d", tempVarN++);
    return putSymb(t, VAR, 0);
}

void yyerror(const char msg[]) {
	printf("Error!!!: %s\n", msg);
}

int main() {
	yyparse();
	return 0;
}
