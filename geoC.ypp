%{
#include <bits/stdc++.h>
#include "symbol.hpp"
using namespace std;
struct Point {
	double x, y;
	Point(double x=0.d, double y=0.d):x(x), y(y) {}
	Point operator +(Point other) {return Point(x+other.x, y+other.y);}
	Point operator -(Point other) {return Point(x-other.x, y-other.y);}
	Point operator *(double c) {return Point(x*c, y*c);}
	Point operator /(double c) {return Point(x/c, y/c);}
	bool operator <(Point other) {return x<other.x or x==other.x and y<other.y;}
	bool operator >(Point other) {return other < *this;}
	bool operator ==(Point other) {return x==other.x and y==other.y;}
	bool operator !=(Point other) {return not(*this==other);}
	bool operator <=(Point other) {return *this<other or *this==other;}
	bool operator >=(Point other) {return other<=*this;}
};
void yyerror(const char*);
char lexema[maxN];
int yylex();
int tempVarN = 0;
int genTempVar();
%}

%start program
%token POINT
%token NUM VAR
%token ADD SUB 
%token MUL DIV
%token POW
%token AND OR
%token OP CP
%token OB CB
%token EQUAL ASSING DIFF
%token INIT END
%token IF ELSE
%token WHILE FOR COMPARATOR
%token DOTCOM CONMA
%token DATATYPE

%%

program: INIT block END;

block: 
	| block control_flow
	| block funcion
	| block creation
;


control_flow: if | for | while;

if: IF OP logic_list CP OB block CB;
while: WHILE OP logic_list CP OB block CB;
for: FOR OP declaration DOTCOM logic_list DOTCOM creation CB OB block CB;


funcion: VAR OP args CP OB block CB;


args:
	| arg
	| args CONMA arg
;

arg: term
;

logic_list: condition
	| logic_list AND condition
	| logic_list OR condition
;

condition: term COMPARATOR term;

creation: assignation | declaration;


assignation: term EQUAL exp {genCode(ASSING, $1, $3, '-');} DOTCOM;

declaration: DATATYPE VAR {$2 = putSymb(lexema, VAR, 0);} EQUAL exp { genCode(ASSING, $2, $5, '-'); } DOTCOM;

exp: factor
	| exp ADD factor {int i = genTempVar(); genCode(ADD, i, $1, $3); $$ = i; }
	| exp SUB factor {int i = genTempVar(); genCode(SUB, i, $1, $3); $$ = i; }
;

factor: factor2
	| factor MUL factor2 {int i = genTempVar(); genCode(MUL, i, $1, $3); $$ = i; }
	| factor DIV factor2 {int i = genTempVar(); genCode(DIV, i, $1, $3); $$ = i; }
;

factor2: term
	| factor2 POW NUM { int i = genTempVar(); genCode(POW, i, $1, $3); $$ = i; }
	| OP exp CP
;

term: VAR { $$ = putSymb(lexema, VAR, 0); }
	| NUM { $$ = putSymb(lexema, NUM, 1); }
	| point { $$ = putSymb(lexema, POINT, 0);}
;

point: '[' NUM CONMA NUM ']'; 

%%

int find(char* lexema) {
	if (strcasecmp(lexema, "init") == 0) return INIT;
	if (strcasecmp(lexema, "end") == 0) return END;
	if (strcasecmp(lexema, "if") == 0) return IF;
	if (strcasecmp(lexema, "for") == 0) return FOR;
	if (strcasecmp(lexema, "while") == 0) return WHILE;
	if (strcasecmp(lexema, "int") == 0) return DATATYPE;
	if (strcasecmp(lexema, "double") == 0) return DATATYPE;
	if (strcasecmp(lexema, "float") == 0) return DATATYPE;
	if (strcasecmp(lexema, "point") == 0) return DATATYPE;
	return VAR;
}

int yylex() {
	register int c = getchar();
	if (isspace(c)) return yylex();
	if (c == '+') return ADD;
	if (c == '-') return SUB;
	if (c == '*') return MUL;
	if (c == '/') return DIV;
	if (c == '(') return OP;
	if (c == ')') return CP;
	if (c == '{') return OB;
	if (c == '}') return CB;
	if (c == '[') return c;
	if (c == ']') return c;
	if (c == '=') return EQUAL;
	if (c == ';') return DOTCOM;
	if (c == ',') return CONMA;
	if (isdigit(c)) {
		int n = 0;
		while (isdigit(c)) {
			lexema[n++] = c;
			c = getchar();
		}		
		lexema[n] = 0;
		ungetc(c, stdin);
		return NUM;
	}
	if (isalpha(c)) {
		int n = 0;
		while (isalnum(c)) {
			lexema[n++] = c;
			c = getchar();
		}
		lexema[n] = 0;
		ungetc(c, stdin);
		return find(lexema);
	}
	return c;
}

int genTempVar() {
    char t[64];
    sprintf(t, "T_%d", tempVarN++);
    return putSymb(t, VAR, 0);
}

void yyerror(const char msg[]) {
	printf("Error!!!: %s\n", msg);
}

int main() {
	yyparse();
	return 0;
}
